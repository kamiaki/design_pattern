# 设计模式



## 设计模式分类

### 创建型模式		5种

单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式

### 结构型模式		7种

适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式

### 行为型模式		11种

策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式



## 设计模式目的

```
1.复用性			代码不重复
2.可读性			见代码知意
3.扩展性			便于新增功能
4.可靠性			增加功能，原功能无影响
5.高内聚，低耦合	功能独立，降低模块间依赖

核心思想是一个"分"字，大的功能拆分成小的，逐一击破
分而治之
类就相当于人，方法就是他会做的事，你让一个人做太多事就会出错。
把事情拆分，给好多人去做，出了问题直接找到，做这件事的人，做这件事的人不行直接换掉。
毕生发明活字印刷是松耦合，雕版印刷耦合度太高了，毕生设计模式大师

实现手段
找到代码中变化的点，这个点用设计模式重构
将不变的地方抽取出来变成接口，将变化的地方抽取出来变成实现封装起来
```



## 七大原则

```
1、单一职责原则【single responsibility principle】：
可靠性
功能A和功能B，都放在同一个类S中，类S粒度高。修改功能A，需要修改类S。因此也修改了功能B的类，可靠性降低。
可读性 扩展性
类S拆分成A类和B类，粒度降低。每个类代表一个功能，可读性提高。增加功能在特定类中增加，扩展性强。


2、接口隔离原则【interface segregation principle】：
可靠性 可读性 扩展性
接口里的方法要少，功能要单一。不要一个接口放好多功能方法。一个接口干一件事，避免肥接口。


3、依赖倒置原则【dependence inversion principle】：
高内聚，低耦合
高层次的模块不应该依赖低层次的模块, 他应该依赖于抽象或接口
就是你调用的是接口的方法，不是实现方法的类
class Client{
    public void do(Server server){}
}
abstract class Server{
    public abstract void service(){}
}
class Waiter extends Server{
    @Override
    public void service(){}
}


4、迪米特法则【low of demeter】：
高内聚，低耦合，最少知道原则
增加一个中介， 比如不直接new对象，我用工厂new对象，工厂就是中介。我和new的对象就解耦了。工厂就是变化点。
类A调用类C，是靠类A先调用类B，类B再调用类C的话，就不要让类A直接调用类C。
类A和B耦合，就不要让类A再和C耦合，尽量减少类之间的耦合。


5、开闭原则【open close principle】：
可靠性
对扩展开放，对修改关闭
扩展性
用接口的方式构建系统，用改变实现的方式，改变行为。而不是通过改变现有代码。


6、里氏替换原则【liskov substitution principle】：符合开闭原则
复用性 
子类不要重写父类的方法，子类可以完全替换父类，不影响父类方法。
高内聚，低耦合
继承增加了耦合度，尽量使用聚合，组合，依赖，来替换继承
扩展性 可靠性
子类重写父类方法，不如自己写新方法，调用老方法，入参比父类简单，出参比父类复杂。


7、组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】：符合里氏替换，符合开闭原则
可扩展
尽量使用组合和聚合少使用继承的关系来达到复用的原则。（外观模式）
可靠性
改变一个类，对其他类无影响
```



## 各种关系

泛化 实现 关联 组合 聚合 依赖

```
泛化	实线三角 指向父类
类继承，接口继承


实现	虚线三角 指向接口
接口实现


依赖	虚线箭头	总类指向参数
一个对象的方法，需要借助其他对象的方法，来实现功能，其他对象作为参数传入方法
public interface Car{
    public void move();
}
public class Driver{
    public void drive(Car car)    {
        car.move();
    }
}


关联	实线箭头 总类指向成员
一个类里面，的成员变量是另一个类
public class Address{
}
public class Customer{
    private Address address;
}


聚合	空心菱形 + 箭头 总类指向外部独立成员
一个对象是由其他对象构成的，构造方法来构造，对象没了，其他对象还在
public class Engine{
}
public class Wheel{
}
public class Light{
}
public class Car{
    private Engine engine;
    private Light light;
    private Wheel wheel;
    public Car(Engine engine, Light light, Wheel wheel) {
        super();
        this.engine = engine;
        this.light = light;
        this.wheel = wheel;
    }
    public void drive() { 
    }
}


组合	实心菱形 + 箭头 总类指向内部成员
一个对象，用其他对象组合的，在构造方法里new的，对象没了，其他对象也没了
public class Mouth{
}
public class Nose{
}
public class Head{
    private Mouth mouth;
    private Nose nose;    
    public Head()    {
        mouth = new Mouth();
        nose = new Nose();
    }
    
    public void shake()    {       
    }
}
```



# 设计模式详解

## 创建型模式	 5

### 1.单例模式

#### 懒汉式

双重校验所，保证线程安全

#### 饿汉式

浪费内存

#### 枚举式

最好的实现，解决单例破坏

#### 内部类式

就是炫技

### 工厂模式

#### 简单工厂

简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。

不支持扩展，一个维度 ，不支持扩展指的是，工厂不支持扩展，只能修改。

#### 2.工厂方法

指的是定义出一个用于创建对象的接口，让子类决定实例化哪个类 

支持扩展，一个维度，工厂可以进行扩展

#### 3.抽象工厂

抽象工厂就是一个工厂创建两个或多个产品，工厂是一个维度，产品是一个维度。

支持扩展，产品+工厂，两个维度

### 4.建造者模式

当构建生成一个对象的时候，需要包含多个步骤，虽然每个步骤具体的实现不同，但是都遵循一定的流程与规则

### 5.原型模式 

又可以叫 复制模式 

new出一个对象之后，在new若干个一样的对象的时候，直接clone。降低new对象的复杂度。

主要是靠 implements Cloneable 实现

实例：spring bean 单例模式 原型模型 ，原型模型就是通过复制实现的。

原型模式 + 工厂模式



## 结构型模式	 7

### 1.适配器模式

一个类S中的方法，无法满足功能需求，就在这个类中添加 if 语句，走到适配器中，用适配器中的类的方法来实现功能。

适配器，也实现S类实现的接口，这样适配器就必须完成接口中的方法。

适配器中要关联一个接口，这个接口的实现类，可以完成适配器中，需要实现S类接口的功能。

### 2.装饰者模式

被装饰的类 和 装饰器类 拥有相同的超类型，因为装饰者和被装饰者必须是一样的类型

**利用继承是为了达到类型匹配，而不是利用继承获得行为**

作用就是通过装饰器，装饰之后获得和之前一样方法的类，但功能增加了。

例子：

FileInputStream fileInputStream = new FileInputStream(new File(""));
fileInputStream.read();
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
bufferedInputStream.read();

### 3.代理模式

#### 静态代理

调用方法用的是代理类，换代理，需要改调用代码

类S实现接口T，一个代理类L实现接口T

L拿到S的对象后，同S一样的方法，在里面调用S的方法，进行处理，生成代理类处理后的方法。

#### 动态代理

调用方法调用的是原来的类，换代理，不用修改调用代码

主要靠 org.springframework.cglib.proxy.InvocationHandler 实现

### 4.外观模式

将许多的类中的方法封装成一个方法。

类搞到一起用的关系是，组合关系，构造方法new对象，然后方法分别调用，每个类的方法。

### 5.桥接模式

理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。 

在抽象类里，放一个对象属性是一个接口，这样抽象类的方法，和接口方法就独立了，互不影响。

### 6.组合模式

组合能够让我们用一致的方式处理个别对象以及对象集合。

拥有同父类，相同的方法，在一个类里统一处理。（放在list里，然后循环执行）

### 7.享元模式

蝇量模式节约了内存空间，减少了对象创建时间。

静态对象属性，重复使用。





## 行为型模式	 11

策略模式、状态模式、观察者模式、命令模式、模板模式、迭代器模式、备忘录模式、解释器模式、责任链模式、访问者模式、中介者模式

### 1.策略模式

定义一种算法，将每个算法都封装起来，并且使他们之间可以互换。线程池就用到了策略模式。

例子：Jdk中的TreeSet和 TreeMap的排序功能就是使用了策略模式 

### 2.状态模式

状态关注的是，某一状态下的一系列行为。策略模式关注一个点，状态模式关注状态下所有点。

状态接口的实现，是在这个实现状态下，各种方法不同的实现。

### 3.观察者模式

定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 

可观察者类继承一个接口，接口方法有添加，删除，通知，改变等，可观察者里面有list存放观察者。

观察者里面有被观察者改变后，需要执行的方法。在观察者改变时，被调用。

### 4.命令模式

将命令，执行者，分离。中间增加一层。需求变化，每次只需要增加命令就可以。

执行者类，有方法接收命令。命令继承命令父类，继承父类的执行命令方法。

### 5.模板模式

 它的子类可以根据需要重写方法实现，但调用的方式与抽象类定义的方式相同。

抽象父类有调用所有方法的方法，具体方法实现分别写在子类里面。

### 6.迭代器模式

提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

定义集合类的接口，接口实现类具体实现了，添加删除元素，获取迭代器等方法，然后定义迭代器接口，定义迭代器的实现，实现了顺序访问每一个元素等方法。

### 7.备忘录模式

在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。 

一个类是管理者，把原对象拷贝到备忘录对象上。原对象有一个方法，把管理者中备忘录对象恢复到原对象上。

### 8.解释器模式

解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语句中的句子。mybatisplus的querywepper

### 9.责任链模式

谁处理得了就给谁，一级一级往下传，都处理不了，就给总部抽象类

### 10.访问者模式

封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下，定义作用于这些元素的新操作。

总的而言，访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。 

### 11.中介者模式

中介者模式是用一个中介对象，来封装一系列对象的交互。 





