# 设计模式



## 设计模式分类

### 创建型模式		5种

单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式

### 结构型模式		7种

适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式

### 行为型模式		11种

策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式



## 设计模式目的

```
1.复用性			代码不重复
2.可读性			见代码知意
3.扩展性			便于新增功能
4.可靠性			增加功能，原功能无影响
5.高内聚，低耦合	功能独立，降低模块间依赖

核心思想是一个"分"字，大的功能拆分成小的，逐一击破
分而治之
类就相当于人，方法就是他会做的事，你让一个人做太多事就会出错。
把事情拆分，给好多人去做，出了问题直接找到，做这件事的人，做这件事的人不行直接换掉。
毕生发明活字印刷是松耦合，雕版印刷耦合度太高了，毕生设计模式大师
```



## 七大原则

```
1、单一职责原则【single responsibility principle】：
可靠性
功能A和功能B，都放在同一个类S中，类S粒度高。修改功能A，需要修改类S。因此也修改了功能B的类，可靠性降低。
可读性 扩展性
类S拆分成A类和B类，粒度降低。每个类代表一个功能，可读性提高。增加功能在特定类中增加，扩展性强。


2、里氏替换原则【liskov substitution principle】：
复用性 
子类不要重写父类的方法，子类可以完全替换父类，不影响父类方法。
高内聚，低耦合
继承增加了耦合度，尽量使用聚合，组合，依赖，来替换继承
扩展性 可靠性
子类重写父类方法，不如自己写新方法，调用老方法，入参比父类简单，出参比父类复杂。


3、依赖倒置原则【dependence inversion principle】：
高内聚，低耦合
高层次的模块不应该依赖低层次的模块, 他应该依赖于抽象或接口
就是你调用的是接口的方法，不是实现方法的类
class Client{
    public void do(Server server){}
}
abstract class Server{
    public abstract void service(){}
}
class Waiter extends Server{
    @Override
    public void service(){}
}


4、接口隔离原则【interface segregation principle】：
可靠性 可读性 扩展性
接口里的方法要少，功能要单一。不要一个接口放好多功能方法。一个接口干一件事，避免肥接口。


5、迪米特法则【low of demeter】：
高内聚，低耦合
最少知识原则，一个类调用另一个类的方法，需要调用3个，把这3个合成一个来调用。把3个方法隐藏成1个，参数也尽量少。


6、开闭原则【open close principle】：
可靠性
对扩展开放，对修改关闭
扩展性
用接口的方式构建系统，用改变实现的方式，改变行为。而不是通过改变现有代码。


7、组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】：
可扩展
尽量使用组合和聚合少使用继承的关系来达到复用的原则。（外观模式）
可靠性
改变一个类，对其他类无影响
```



## 各种关系

```
关联	
一个对象的属性是另一个对象
public class Address{
}
public class Customer{
    private Address address;
}

聚合
一个对象是由其他对象构成的，构造方法来构造，对象没了，其他对象还在
public class Engine{
}
public class Wheel{
}
public class Light{
}
public class Car{
    private Engine engine;
    private Light light;
    private Wheel wheel;
    public Car(Engine engine, Light light, Wheel wheel) {
        super();
        this.engine = engine;
        this.light = light;
        this.wheel = wheel;
    }
    public void drive() { 
    }
}

组合
一个对象，用其他对象组合的，在构造方法里new的，对象没了，其他对象也没了
public class Mouth{
}
public class Nose{
}
public class Head{
    private Mouth mouth;
    private Nose nose;    
    public Head()    {
        mouth = new Mouth();
        nose = new Nose();
    }
    
    public void shake()    {       
    }
}

依赖
一个对象的方法，需要借助其他对象的方法，来实现功能，其他对象作为参数传入方法
public interface Car{
    public void move();
}
public class Driver{
    public void drive(Car car)    {
        car.move();
    }
}
```



# 设计模式详解

## 创建型模式	 5

### 1.单例模式

#### 懒汉式

双重校验所，保证线程安全

#### 饿汉式

浪费内存

#### 枚举式

最好的实现，解决单例破坏

#### 内部类式

就是炫技

### 工厂模式

#### 简单工厂

简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。 

```
不支持扩展 一个维度
```

#### 2.工厂方法

工厂方法是针**对每一种产品提供一个工厂类**。通过不同的工厂实例来创建不同的产品实例。

在同一等级结构中，**支持增加任意产品**。

```
支持扩展 一个维度
```

#### 3.抽象工厂

抽象工厂是应对产品族概念的。比如说，每个汽车公司可能要同时生产轿车，货车，客车，那么每一个工厂都要有创建轿车，货车和客车的方法。 

```
支持扩展 产品族 两个维度
```

### 4.建造者模式

生成器模式的核心是 ** 当构建生成一个对象的时候，需要包含多个步骤，虽然每个步骤具体的实现不同，但是都遵循一定的流程与规则 ** 

### 5.原型模式

通过上述内容，你大概也知道了原型模型的应用场景，那就是“当new一个对象成本较高的时候”



## 结构型模式	 7

### 1.适配器模式

适配器模式作为两个不兼容接口之间的桥梁。 这种类型的设计模式属于结构模式，因为该模式组合了两个独立接口。 

### 2.装饰者模式

装饰者和被装饰者对象有相同的超类型，因为装饰者和被装饰者必须是一样的类型，**这里利用继承是为了达到类型匹配，而不是利用继承获得行为。** 

### 3.代理模式

#### 静态代理

必须修改代码，增加被代理类

#### 动态代理

不用修改代码，增加被代理类

### 4.外观模式

将许多的类中的方法封装成一个方法。

### 5.桥接模式

理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。 

### 6.组合模式

组合能够让我们用一致的方式处理个别对象以及对象集合。

### 7.享元模式

蝇量模式节约了内存空间，减少了对象创建时间。





## 行为型模式	 11

策略模式、状态模式、观察者模式、命令模式、模板模式、迭代器模式、备忘录模式、解释器模式、责任链模式、访问者模式、中介者模式

### 1.策略模式

定义一种算法，将每个算法都封装起来，并且使他们之间可以互换。线程池就用到了策略模式。

### 2.状态模式

状态关注的是，某一状态下的一系列行为。策略模式关注一个点，状态模式关注状态下所有点。

### 3.观察者模式

定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 

### 4.命令模式

将命令，执行者，分离。中间增加一层。需求变化，每次只需要增加命令就可以。

### 5.模板模式

 它的子类可以根据需要重写方法实现，但调用的方式与抽象类定义的方式相同。

### 6.迭代器模式

提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

### 7.备忘录模式

在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。 

### 8.解释器模式

解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语句中的句子。mybatisplus的querywepper

### 9.责任链模式

谁处理得了就给谁，一级一级往下传，都处理不了，就给总部抽象类

### 10.访问者模式

封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下，定义作用于这些元素的新操作。

总的而言，访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。 

### 11.中介者模式

中介者模式是用一个中介对象，来封装一系列对象的交互。 





