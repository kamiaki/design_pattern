# 设计模式

## 七大原则

```
1、单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】：
一个类负责一项职责.

2、里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】：
尽量不要重写父类的已经实现了的方法，可以用接口等其他方法绕过

3、依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】：
即针对接口编程，不要针对实现编程.构建大型项目，只关注接口做什么的，不关注怎么实现的。

4、接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】：
建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少.

5、迪米特法则【LOW OF DEMETER】：
低耦合，高内聚.

6、开闭原则【OPEN CLOSE PRINCIPLE】：
对扩展开放，对修改关闭.

7、组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】：
尽量使用组合和聚合少使用继承的关系来达到复用的原则.（外观模式）
```



## 策略模式

定义一种算法，将每个算法都封装起来，并且使他们之间可以互换。线程池就用到了策略模式。



## 状态模式

状态关注的是，某一状态下的一系列行为。策略模式关注一个点，状态模式关注状态下所有点。



## 观察者模式

定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 



## 装饰者模式

装饰者和被装饰者对象有相同的超类型，因为装饰者和被装饰者必须是一样的类型，**这里利用继承是为了达到类型匹配，而不是利用继承获得行为。** 



## 命令模式

将命令，执行者，分离。中间增加一层。需求变化，每次只需要增加命令就可以。



## 外观模式

将许多的类中的方法封装成一个方法。



## 模板模式

 它的子类可以根据需要重写方法实现，但调用的方式与抽象类定义的方式相同。



## 迭代器模式

提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。



## 组合模式

组合能够让我们用一致的方式处理个别对象以及对象集合。



## 备忘录模式

在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。 



## 解释器模式

**解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语句中的句子。** 

mybatisplus的querywepper



## 复合模式

是用来表示部分以及整体层次的一种递归式结构的模式 



## 蝇量模式 享元模式

蝇量模式节约了内存空间，减少了对象创建时间。



## 访问者模式

**封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下，定义作用于这些元素的新操作。** 

总的而言，访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。 



## 工厂模式

### 简单工厂

简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。 

```
不支持扩展 一个维度
```

### 工厂方法

工厂方法是针**对每一种产品提供一个工厂类**。通过不同的工厂实例来创建不同的产品实例。

在同一等级结构中，**支持增加任意产品**。

```
支持扩展 一个维度
```

### 抽象工厂

抽象工厂是应对产品族概念的。比如说，每个汽车公司可能要同时生产轿车，货车，客车，那么每一个工厂都要有创建轿车，货车和客车的方法。 

```
支持扩展 产品族 两个维度
```



## 单例模式

### 懒汉式 

保证线程安全，防止单例破坏

### 饿汉式

浪费内存

### 枚举式

解决单例破坏

### 内部类式

就是炫技



## 中介者模式

中介者模式是用一个中介对象，来封装一系列对象的交互。 



## 桥接模式

理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。 



## 责任链模式

谁处理得了就给谁，一级一级往下传，都处理不了，就给总部抽象类



## 适配器模式

适配器模式作为两个不兼容接口之间的桥梁。 这种类型的设计模式属于结构模式，因为该模式组合了两个独立接口。 



## 生成器模式

生成器模式的核心是 ** 当构建生成一个对象的时候，需要包含多个步骤，虽然每个步骤具体的实现不同，但是都遵循一定的流程与规则 ** 



## 原型模式

通过上述内容，你大概也知道了原型模型的应用场景，那就是“当new一个对象成本较高的时候”



## 代理模式

### 静态代理

必须修改代码，增加被代理类

### 动态代理

不用修改代码，增加被代理类